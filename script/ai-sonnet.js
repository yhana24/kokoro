const axios = require("axios");
const fs = require('fs');
const path = require('path');

module.exports["config"] = {
    name: "sonnet",
    aliases: ["cs", "claudesonnet", "ai"],
    version: "1.0.0",
    credits: "Kenneth Panio",
    role: 0,
    isPrefix: false,
    type: "artificial-intelligence",
    info: "Interact with Claude Sonnet.",
    usage: "[prompt]",
    guide: "sonnet How does nuclear fusion work?",
    isPremium: true,
    limit: 5,
    cd: 6
};

const conversationHistories = {};

module.exports["run"] = async ({ chat, args, event, font, global }) => {
    var mono = txt => font.monospace(txt);
    const { threadID, senderID } = event;
    const query = args.join(" ");
    
    if (!query) return chat.reply(font.thin("Please provide a text to ask. e.g: sonnet what is love?"));

    if (['clear', 'reset', 'forgot', 'forget'].includes(query.toLowerCase())) {
        conversationHistories[senderID] = [];
        chat.reply(mono("Conversation history cleared."));
        return;
    }

    const answering = await chat.reply(mono("ðŸ• | Generating Response..."));

    conversationHistories[senderID] = conversationHistories[senderID] || [];
    conversationHistories[senderID].push({ role: "user", content: query });
    
    const model = "claude-sonnet-3.5";

    const getResponse = async (useModel = true) => {
        return axios.post(global.api["chatbox"], {
            messages: conversationHistories[senderID],
            clickedContinue: false,
            previewToken: null,
            agentMode: {},
            trendingAgentMode: {},
            isMicMode: false,
            webSearchMode: false,
            codeModelMode: false,
            isChromeExt: false,
            clickedAnswer2: false,
            clickedAnswer3: false,
            githubToken: atob("Z2hwX3V5VEZydEViQ051WjVQaVdhV3d3bHlrT1dnR0p2OTM5NEk4Mg=="),
            userSystemPrompt: null,
            visitFromDelta: false,
            mobileClient: false,
            maxTokens: '999999999999',
            userSelectedModel: useModel ? model : null
        });
    };

    const maxRetries = 3;
    let attempts = 0;
    let success = false;
    let answer = "Under Maintenance!\n\nPlease use other models get started with 'help'";

    while (attempts < maxRetries && !success) {
        try {
            const response = await getResponse(attempts === 0);
            answer = response.data.replace(/\$@\$(.*?)\$@\$/g, '').trim();
            success = true;
        } catch (error) {
            attempts++;
            if (attempts < maxRetries) {
                await answering.edit(mono(`No response from Claude Sonnet AI. Retrying... (${attempts} of ${maxRetries} attempts)`));
                await new Promise(resolve => setTimeout(resolve, 1000 * attempts));
            } else {
                answering.edit(mono("No response from Claude Sonnet AI. Please try again later: " + error.message));
                return;
            }
        }
    }

    if (success) {
        conversationHistories[senderID].push({
            role: "assistant", content: answer
        });

        const codeBlocks = answer.match(/```[\s\S]*?```/g) || [];
        const line = "\n" + 'â”'.repeat(18) + "\n";
        
        answer = answer.replace(/Generated by BLACKBOX\.AI, try unlimited chat https:\/\/www\.blackbox\.ai/g, "").trim();

        answer = answer.replace(/\*\*(.*?)\*\*/g, (_, text) => font.bold(text));

        const message = font.bold("ðŸ›°ï¸ | " + model.toUpperCase() || "BLACKBOX AI") + line + answer + line + mono(`â—‰ USE "CLEAR" TO RESET CONVERSATION.`);

        await answering.edit(message);

        if (codeBlocks.length > 0) {
            const allCode = codeBlocks.map(block => block.replace(/```/g, '').trim()).join('\n\n\n');
            const cacheFolderPath = path.join(__dirname, "cache");

            if (!fs.existsSync(cacheFolderPath)) {
                fs.mkdirSync(cacheFolderPath);
            }

            const uniqueFileName = `code_snippet_${Math.floor(Math.random() * 1e6)}.txt`;
            const filePath = path.join(cacheFolderPath, uniqueFileName);

            fs.writeFileSync(filePath, allCode, 'utf8');

            const fileStream = fs.createReadStream(filePath);
            await chat.reply({
                attachment: fileStream
            });

            fs.unlinkSync(filePath);
        }
    }
};
